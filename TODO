dmop -> base
dstruct -> serialization , map, list protocol -> gestion thread /erreur ,exception / type objet -> cow , read etc...
dforensicslib -> ntfs, fat , ... que du dstruct (description des structure

dff interface dstruct + dforensicslib 

serialization en protocol

objet - > cow 

dobjet->getCOW() 
dobjetCOW->getValue
                -> self.read(parent.data)
                return value

dobjectCOW->setValue(23)
            -> self.value = 23  //possibilite de cache des data modifier

dobjectCOW->readValue() 
                if self.value:
                  return self.value
                else
                 self.read(parent.data) -> dynamic permet de pas stocker/read a chaque fois toute les value des objet -> possibilite de cache en ram ou autrE? self->value=  23


dobjectCOW->deserialize:

                if self.value:
                  write(self.value)
                else:
                   value =  self.read(parent.data)
                   self.write(value)

permet d avoir des objet dynamic qui read pas tout 
possibilite (decrire ds le constructeur quuq chose qui verifie un magic ou autre pour verifier si l objet est ok) 
pouvoir recall /. recree l objet s il est update par exemple ! ou alors reset tout les self.value ou ecrit les self.value puis get les nouvelle value ? 



serialization ( map / list)


serializeRaw(map) 

    map.serialize()
        doit pouvoir
                xml
                raw
                json 
                ...                     

        algo special par rappotr a un autre objet/container

               json: {key, value; key,value}
               raw  nkey
                    key, len(values), values, ....

        pareille pour list

        mais par ex un new datatype:
                pascalstring

                raw / sera diffrent mais pas les autre serializer : json/python c comme une autre string

        ou un bootsector par ex meme si raw devrait suffier avec un type data buffer

        doit aussi pouvoir streamer list.serialize() > gz > aes


        et savoir read/write ds le flux de la stream et pas juste le modifier 

        list.serialize > gz > aes 

        list.serialize > gz > aes  (en ram)

        list.sserialize > gz > aes > tofile

        fromfile < read < desialize < aes.decrypt() < gunzip <  list

        fromvfs < read < deserialize < aes.decrypt() < gunzip < ntfs.data < ntfsnode ...

                                                  data = .zip           module unzip
        fromvfs < read < deserialize < ntfs.data < ntfsnode .. < fs < zip < read


         
        fromvfs < read < deserialize < ntfs.data < ntfsnode .. < fs < zip > tmpfs  < read

        if dmodule < dserialize not had attribute seek use tmpfs

        ...

heritage + attribut


dstring

dstring.dserializeRaw()

dpascalstring(dstring):

par default

dpascalstring.dserializeRaw(): dstring.dserializeRaw()


overrige

dspascalstring.dserializeRaw() writeRaw(...) 



utilisation 

dsraw = DSerialize("Raw") ou DserializeRaw ou DObject("dserializeraw")

dsraw.deserialize(mypascalstring)
        -> mypascalstring.dserializeRaw()

                

autre exemple:

mytoto(dobject):
  pascalstring name
  int32        prout


dsraw.desrialize(mytoto)
  dobject->dserializeRaw
                for i in attriubte:
                    write.attributeName()
                    write(attriubte.deserializeRaw())


                        sttribute::name-> mypascalstring.deserializeRaw
                        attriubte:prout -> dint32.dserializeRaw



le problem de cette archi c qu on ovveride les methodes qui ok peuvent appeller autre chose si existe pas :

par ex : dseriailzer('xml') si il n y ap as de string->dserializeXML peut apeller string->dserializeRaw ou string->dsierlizeText par default

donc XMLDSerialize(TextDesirializer)  heritge pour appeller le plus proche si pas implem

        TextDeserializer(throw)  ou TextDeserializer(Raw) meme si on peut image text/string et raw en default pour tous les dattributs

mais si le deserializer et vriament pas implem : 

dserializer("brainfuck") -> can't call dint32->dserializeBrainfuck

du coup on se dit bon je doit reimplem et modifier DINt32 pour lui rajouter une method deserializeBrainfuck 
ou espere qu ils soit un dynamic objet et faire un dint32.addmethod(dserializebrainfuck) 

ou encore auter possibilite avec par ex de l heritage croise ? 

dserialize("brainfuck")  dint32->dserializeBrainfuck
                                didnt'exist try 
                                        DSerializeBrainFuck.dserializeDInt32 
                                un peu spe mais ca permet d implem qud meme ds DSerializeBrainFuck 

ou alors : 

DSerializeBrainfuck:dserializeInt32 

dint32.add(DSerializeBrainfuck)

ou globalDobject.add(dserializebrainfuck) 

donc ca call entre les 2 peut etre des prob de recursion mais peut etre interessant si on veut pas modifier les objet de base a chaque fois donc tous passe par le mop

et ca permet donc de faire un deserializeBrainFuck.deserializeInt32 implem en python par exemple

 

                
                    
  



===============================================

Embedding python : 

On peu call un object python mais on peu pas le register ds destruct avec les methods et cree l objet python en c++ 
on peu juste passer un objet deja cree avec c method, il faut un MakeDNewClass en python pour pouvoir enregistrer la classe !
 
// designe des NODES 

time = node()->accessedTime() 
node()->accessedTime()->ntfs->..->read_attribute(node->id)
node.deleted() => True
node.exif().maker()

comme ac c tjrs dynamique que par fonction et apres avoir un parse
qui parse le tree comme le scanner et maintient a jour une liste ou un cach pour pouvoir y accedder par path en fait c un container tree qui itere en background sur la liste de node et en met en cache et maintienetnt le nombre a jour ca permet de cache d apres la memoire comme un garbage collector 

et du coup on a juste a coder l iterateur du tree pour etre mis a jour et maintenir different type de tree

par un ex un autre type de tree pourrait linker les node par metadata pour les retrouer plus vites

indexer pourrait iterer sur le tree qui est un container pour avoir les info 
comme ca ca reste dynamique et le cache et gerer ds le tree qui est un container donc c logique qu il est un cache des accesseur / find etc... d apres le type de container 

on peut commce ca facilement cree d autre type de tree lie par metadata ou par temps

timeline(accessedTime)
for i in tree:
  timeline.push(accessdTime)

        timeline.push(accesedTime):
            object = tree.get(objectPath)
            meta = object.accessedTIme()
                
            self.list.add(objectPah, meta).sort()
ou 
for i in tree:
  timelineAccessed.push(object.accessedTime()
  timelineCreated.push(object.createdTime()

probleme de connaitre tous les object time qui suive ds cette abre infi si pas indexer ...

node =  tree.get(/tata/tutu/toto)

node = node->children('tata')->children('tutu')node->children('toto')

tree.count() -> 2323 nombre de node

#indexer.index(tree)   -> met a jour un index / cache pour un fast lookup 
index.get()

for i in tree
  index(i)                       

==========> 

XXX setItem -> const/non const a remttre ds dobjet etC

==

idee possibilite  de setValue<>();

comme ca on fait 

setValue<typename t>(string name, DValue RealValue<t>(arg))

 setValue<DObject*>("toto", object): //pas besoin de faire RealValue a chaque fois et conomise juste filer le type !  meme si plus long  a declarer 

pour le retour les function sont en 
DValue qui est un object cree sur la stack

si on fait return ; le compilo dit rien car implicitement il cree un objet sur la stack
met set object et psa set donc cava segault 

il faudrait qu il soit set a DNone par default comme ca pas esoin de ce faire chier a retour DNone 
et encore plus RealValue<DestruDNone ... 
juste return; creera un DValue par default set a dnone (ou qui emule qu il est set a none ne renvoyant des truc par default ) 


